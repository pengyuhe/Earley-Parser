import os,sys
import math
import heapq
from heapq import heappush,heappop, heapify
import copy
from copy import deepcopy





def Attach(Current_Column):
    h=[]
    heapify(h)
    for Entry in Parse_Chart[Current_Column]:
        ### If the dot has reached the end

        if(Entry == None):
            continue



        ### We build a heap for attaching
        ### Always attach those have larger start point first
        ### If the new (generated by attach) entry can be attached (has an empty [Term])
        ### Add it to the heap

        if( len ( Entry[2] ) ==0 ): ### This entry can be an attaching candidate
            Temp_Entry=Entry
            heappush(h,(Temp_Entry[3][0],Temp_Entry))


    while(h):
        ### Temp Entry is in current line
        Temp_TEntry=heappop(h)
        Temp_Entry=Temp_TEntry[1]
        Start_line=Temp_Entry[0]
        Temp_Key=Temp_Entry[1]
        Temp_Weight = Temp_Entry[3][0]

        for Attach_Entry in Parse_Chart[Start_line]:
            ### If it can be attached
            if(Attach_Entry==None):
                continue
            if( len(Attach_Entry[2])==0):
                continue
            if(Attach_Entry[2][0]==Temp_Key):
                ### We construct the Attach_Entry
                ### And determine whether we would like to add it
                New_Attach_Entry=deepcopy(Attach_Entry)

                New_Attach_Entry[2].pop(0)
                New_Attach_Entry[3][0]+=Temp_Weight
                
                ### As for the pointer we always do:
                ### The left branch has a non-empty [Terms]
                ### The right branch is either a terminal or has a empty [Terms]
                New_Attach_Entry[3][1][0]=Attach_Entry
                New_Attach_Entry[3][1][1]=Temp_Entry
                ### Check if this new entry is added to Parse_Chart
                Added=0


                ### Check whether it new entry has been in the current column
                Temp_Hash_value=Hash.get( (Current_Column,(New_Attach_Entry[0],New_Attach_Entry[1],tuple(New_Attach_Entry[2]) ) ), None)
                

                if(Temp_Hash_value==None):   
                    Parse_Chart[Current_Column].append(New_Attach_Entry)

                    Hash[(Current_Column,(New_Attach_Entry[0],New_Attach_Entry[1],tuple(New_Attach_Entry[2]) ) )]=len(Parse_Chart[Current_Column])-1
                    Added=1
                else:
                    Old_Entry=Parse_Chart[Current_Column][Temp_Hash_value]
                    if(Old_Entry[3][0]>New_Attach_Entry[3][0]):
                        Parse_Chart[Current_Column][Temp_Hash_value]=None
                        Parse_Chart[Current_Column].append(New_Attach_Entry)
                        Hash[(Current_Column,(New_Attach_Entry[0],New_Attach_Entry[1],tuple(New_Attach_Entry[2]) ) )]=len(Parse_Chart[Current_Column])-1
                        Added=1
                if(Added==1):
                    if (len(New_Attach_Entry[2])==0):
                        Temp_Entry_local=New_Attach_Entry
                        heappush(h,(Temp_Entry_local[3][0],Temp_Entry_local))
        
        
def Predict(Current_Column):

    ### We use a pointer to go down the chart
    ### Because the first terms are generated by attach
    ### So we can easily start from the head



    Current_Predict=0

    while( Current_Predict < len ( Parse_Chart [ Current_Column ] ) ):
        Predict_Entry=deepcopy(Parse_Chart[Current_Column][Current_Predict])
        
        if(Predict_Entry==None or len(Predict_Entry[2])==0 ):
            Current_Predict+=1
        
            continue


        if(Predict_Entry[2][0] in Grammar_Dic):
            Current_Key=Predict_Entry[2][0]

            for Term in Grammar_Dic[Current_Key]:
                ### We construct the entry, and determine whether it should be added
                ### We do not need back pointer for Predict
                New_Entry=[Current_Column,Current_Key,Term[1],[Term[0],[None,None]]]
                
                Hash_Key=(Current_Column, ( Current_Column,Current_Key,tuple(Term[1])  ) )

                if(Hash_Key not in Hash):
                    Parse_Chart[Current_Column].append(New_Entry)
                    Hash[Hash_Key]=len(Parse_Chart[Current_Column])-1
                else:
                    Temp_Hash_value=Hash[Hash_Key]
                    Old_Entry=deepcopy(Parse_Chart[Current_Column][Temp_Hash_value])

                    if(Old_Entry[3][0]>New_Entry[3][0]):
                        Parse_Chart[Current_Column][Temp_Hash_value]=None
                        Parse_Chart[Current_Column].append(New_Entry)
                        Hash[Hash_Key]=len(Parse_Chart[Current_Column])-1

        
        Current_Predict+=1
                

### Predict: only deal with the non-terminals
### Scan: only deal with the terminals 
### So they will not bother each other

def Scan(Current_Column,S):

    Success=False


    #print("Temp word is",S[Current_Column])
    LC= len(Parse_Chart[Current_Column])

    for i in range(LC-1,-1,-1):
        Temp_Entry=deepcopy(Parse_Chart[Current_Column][i])

        ### Skip all the Non-terminals
        if(Temp_Entry==None):
            continue
        if(len(Temp_Entry[2])==0):
            continue

        if(Temp_Entry[2][0] in Grammar_Dic):
            continue
       

        if(Temp_Entry[2][0]==S[Current_Column]):
            Success=True
            
            ### We construct the new Entry 
            New_Entry=deepcopy(Temp_Entry)
            New_Entry[2].pop(0)
            ### As for the pointer we always do:
            ### The left branch has a non-empty [Terms]
            ### The right branch is either a terminal or has a empty [Terms]
            New_Entry[3][1][0] = Parse_Chart[Current_Column][i]
            New_Entry[3][1][1] = S[Current_Column]

            if len(Parse_Chart)<Current_Column+2:
                Parse_Chart.append([])

            Parse_Chart[Current_Column+1].append(New_Entry)

    return Success


        

def Parse(S):
    
    LS=len(S)
    ###  Check whether the sentence is a single empty symbol
    if (LS==1):
        if(len(S[0])==0):
            return [None,None]




    Parse_Chart.append( [] )

    
    ### Initialize
    ### ROOT may have several rules
    ### Put them all into the chart
    for Element in Grammar_Dic["ROOT"]: 
        Entry=[0,'ROOT',Element[1],[Element[0],[None,None]   ]]
        Parse_Chart[0].append(Entry)

    ### No "ROOT" rule will be added ever again.
    ### No need for putting them into the Hash table
   
    for i in range(0,LS+1):
        
        ### We check each step
        ### 
        Attach(i)
        
        Predict(i)
        
        if(i!=LS):
           Success = Scan(i,S)
           if(Success==False):
               return [None,None]
        
        #Print_Chart(i)
        #input("Press")
    '''
    for i in range(0,LS+1):
        Attach(i)
        Predict(i)
        Scan(i,S)
    '''

    ResultValue=None
    Result=None
    for item in Parse_Chart[LS]:
        if(item==None):
            continue
        if item[1]=='ROOT':
            if (Result==None or ResultValue==None or ResultValue>item[3][0]):
                ResultValue = item[3][0]
                Result=item
    return [Result,ResultValue]

def Print_Chart(i):
    for item in Parse_Chart[i]:
        Pitem=deepcopy(item)
        if(Pitem==None):
            print(None)
            continue
        if( isinstance(Pitem[3][1][0],str) ):
            Temp_key1=Pitem[3][1][0]
        elif(Pitem[3][1][0]==None):
            Temp_key1=None
        else:
            Temp_key1=Pitem[3][1][0][1]


        if( isinstance(Pitem[3][1][1],str) ):
            Temp_key2=Pitem[3][1][1]
        elif(Pitem[3][1][0]==None):
            Temp_key2=None
        else:
            Temp_key2=Pitem[3][1][1][1]

        Pitem=[Pitem[0],Pitem[1],Pitem[2],(Pitem[3][0],Temp_key1,Temp_key2)]
        print(Pitem)
    print("===========")



def BuildTree(Node,Ancestor):
    #print("Ancestor=",Ancestor)
  
    ### Current Node is a terminal
    if( isinstance(Node,str) ):
        Ancestor.append(Node)
        return
    
    ### Current Node is a good non-terminal
    Flag=0
    if(len(Node[2])==0):
        New_Pointer=[Node[1]]
        if(Ancestor==None):
            Ancestor=deepcopy(New_Pointer)
        else:
            Ancestor.append(New_Pointer)
            Flag=1

    try:
        AA=Node[3][1][0]
    except IndexError:
        print("Node=",Node,"Node Len=",len(Node),"Type is",type(Node))
    if(Node[3][1][0]!=None):
        if(Flag):
            BuildTree(Node[3][1][0],New_Pointer)
        else:
            BuildTree(Node[3][1][0],Ancestor)

    if(Node[3][1][1]!=None):
        if(Flag):
            BuildTree(Node[3][1][1],New_Pointer)
        else:
            BuildTree(Node[3][1][1],Ancestor)
    
    return Ancestor


def Tprint(Tree):
    # This function deals with how to properly print the tree structure generate by Generate_Tree
    L=len(Tree)

    # The form of Tree is a recursive list
    # List[ element, List[ element,element, List[....]]]

    # In the beginning of a list, print '('
    print '(',
    for i in range(0,L):
        if(type(Tree[i]) is list):
            # Recursively 
            Tprint(Tree[i])
        else:
            print Tree[i]," ",
        if(i==L-1):
            # In the end, print ')'
            print ')',
if __name__=='__main__':
    try:
        Grammar_file=sys.argv[1]
        Sentence_file=sys.argv[2]
    except ValueError:

        print( "illegal input")
        exit(0)
    
    with open(Grammar_file) as f:
        Grammar_content=f.readlines()

    
    ### We make theses things global:
    ### Parse Chart, Hash table, 
    global Grammar_Dic
    global Parse_Chart
    global Hash


    Grammar_Dic={}
    Parse_Chart=[]
    Hash={}

    # Grammar_Dic['ROOT']= [ ( 1.0,[S] ) ]
    # Grammar_Dic['S']   = [ ( 0.8,[NP,VP] ) ]
    # Grammar_Dic['NP']  = [ ( 0.8,[Det,N] ), ( 0.1,[NP,PP] ) ]



    for Temp_grammar in Grammar_content:
        Temp_grammar=Temp_grammar.strip('\n')
        LS_grammar=Temp_grammar.split('\t')
        #print(LS_grammar)
        Weight=-math.log(float(LS_grammar[0]) )/math.log(2)
        Key=LS_grammar[1]
        Term=LS_grammar[2].split(' ')
        if(Grammar_Dic.get(Key,None)==None):
            Grammar_Dic[Key]=[ (Weight,Term) ]
        else:
            Grammar_Dic[Key].append( (Weight,Term) )

    with open(Sentence_file) as f:
        Sentences=f.readlines()
    
    Tree=[]
    for S in Sentences:
        S=S.strip('\n')
        S=S.split(' ')
        Parse_Chart=[]
        Hash={}
        print("S=",S)
        Tree=Parse(S)
        ### Tree[0] is the raw tree
        ### Tree[1] is the best weight
        if(Tree[0]!=None):
            PrintTree=BuildTree(Tree[0],None)
            Tprint(PrintTree)
            print("Best Weight = ",Tree[1])
        else:
            print(None)
    




